{"version":3,"file":"index.esm.js","sources":["../src/hasher.ts","../src/dopeMap.ts"],"sourcesContent":["export function fastStableHash(\n  value: unknown,\n  options: { sortKeys?: boolean; handleCycles?: boolean } = {\n    sortKeys: false,\n    handleCycles: false,\n  },\n  stack = new WeakSet()\n) {\n  switch (typeof value) {\n    case \"number\":\n      return `n${value}`;\n    case \"string\":\n      return `s${value}`;\n    case \"boolean\":\n      return `b${value}`;\n    case \"undefined\":\n      return \"u\";\n    case \"function\":\n      return `f${value.toString()}`;\n    case \"symbol\":\n      return `y${value.toString()}`;\n    case \"object\": {\n      if (value === null) return \"null\";\n\n      if (options.handleCycles) {\n        if (stack.has(value)) return \"[Circular]\";\n        stack.add(value);\n      }\n\n      if (Array.isArray(value)) {\n        let result = \"a[\";\n        for (let i = 0; i < value.length; i++) {\n          result += `${fastStableHash(value[i], options, stack)},`;\n        }\n        if (options.handleCycles) stack.delete(value);\n        return result + \"]\";\n      }\n\n      let keys = Object.keys(value);\n      if (options.sortKeys) {\n        keys.sort();\n      }\n\n      let result = \"o{\";\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        result += `${key}:${fastStableHash(\n          (value as { [key: string]: unknown })[key],\n          options,\n          stack\n        )}|`;\n      }\n\n      if (options.handleCycles) stack.delete(value);\n      return result + \"}\";\n    }\n  }\n\n  return \"unknown\";\n}\n","import { fastStableHash } from \"./hasher.js\";\nimport {\n  HashedKey,\n  MapEntry,\n  HashFunction,\n  DopeMapConfig,\n  DopeKey,\n  HashConfig,\n} from \"./types.js\";\n\nexport default class DopeMap<V> {\n  private dopeMap: Map<HashedKey, MapEntry<V>>;\n  private primitiveKeys = new Set<HashedKey>([\"string\", \"number\"]);\n  private hashFunction: HashFunction = fastStableHash;\n  private hashConfig: HashConfig | undefined = undefined;\n\n  constructor(config: DopeMapConfig = {}) {\n    this.handleConfig(config);\n    this.dopeMap = new Map();\n  }\n\n  private handleConfig(config?: DopeMapConfig) {\n    if (config?.hashFunction) {\n      if (typeof config.hashFunction !== \"function\") {\n        throw new Error(\n          \"[DOPE] Provided hashFunction must be a function.  Not dope!\"\n        );\n      }\n\n      this.hashFunction = config.hashFunction;\n    } else {\n      this.hashConfig = config?.hashConfig;\n    }\n  }\n\n  private isHashedKey(key: DopeKey): key is HashedKey {\n    return this.primitiveKeys.has(typeof key);\n  }\n\n  private getHashedKey(key: DopeKey) {\n    if (this.isHashedKey(key)) {\n      return key;\n    }\n\n    return this.hashFunction(key, this.hashConfig);\n  }\n\n  set(k: DopeKey, v: V): void {\n    const hashedKey = this.getHashedKey(k);\n    this.dopeMap.set(hashedKey, { k, v });\n  }\n\n  get(k: DopeKey) {\n    const hashedKey = this.getHashedKey(k);\n    const entry = this.dopeMap.get(hashedKey);\n    return entry?.v;\n  }\n\n  has(k: DopeKey) {\n    const hashedKey = this.getHashedKey(k);\n    return this.dopeMap.has(hashedKey);\n  }\n\n  delete(k: DopeKey) {\n    const hashedKey = this.getHashedKey(k);\n    return this.dopeMap.delete(hashedKey);\n  }\n\n  /**\n   * Returns Dope Map's current size\n   */\n  get size() {\n    return this.dopeMap.size;\n  }\n\n  /**\n   * Returns the full Dope Map as an object\n   */\n  getMap() {\n    return Object.fromEntries(this.dopeMap.entries());\n  }\n\n  clear() {\n    return this.dopeMap.clear();\n  }\n\n  entries(asArray: true): [DopeKey, V][];\n  entries(asArray?: false): IterableIterator<[DopeKey, V]>;\n  entries(asArray?: boolean): [DopeKey, V][] | IterableIterator<[DopeKey, V]> {\n    const iterator = (function* (map: Map<HashedKey, MapEntry<V>>) {\n      for (const { k, v } of map.values()) {\n        yield [k, v] as [DopeKey, V];\n      }\n    })(this.dopeMap);\n\n    return asArray ? Array.from(iterator) : iterator;\n  }\n\n  forEach(callback: (value: V, key: DopeKey, map: this) => void): void {\n    for (const { k, v } of this.dopeMap.values()) {\n      callback(v, k, this);\n    }\n  }\n\n  keys(asArray: true): DopeKey[];\n  keys(asArray?: false): IterableIterator<DopeKey>;\n  keys(asArray?: boolean): DopeKey[] | IterableIterator<DopeKey> {\n    const iterator = (function* (map: Map<HashedKey, MapEntry<V>>) {\n      for (const { k } of map.values()) {\n        yield k;\n      }\n    })(this.dopeMap);\n\n    return asArray ? Array.from(iterator) : iterator;\n  }\n\n  values(asArray: true): V[];\n  values(asArray?: false): IterableIterator<V>;\n  values(asArray?: boolean): V[] | IterableIterator<V> {\n    const iterator = (function* (map: Map<HashedKey, MapEntry<V>>) {\n      for (const { v } of map.values()) {\n        yield v;\n      }\n    })(this.dopeMap);\n\n    return asArray ? Array.from(iterator) : iterator;\n  }\n}\n"],"names":["fastStableHash","value","options","sortKeys","handleCycles","stack","WeakSet","toString","has","add","Array","isArray","result","i","length","delete","keys","Object","sort","key","dopeMap","primitiveKeys","Set","hashFunction","hashConfig","undefined","constructor","config","this","handleConfig","Map","Error","isHashedKey","getHashedKey","set","k","v","hashedKey","get","entry","size","getMap","fromEntries","entries","clear","asArray","iterator","map","values","from","forEach","callback"],"mappings":"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"}